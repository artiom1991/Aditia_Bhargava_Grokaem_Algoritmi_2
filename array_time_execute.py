import time

# Так как под массив выделяется в оперативной памяти последовательные ячейки одна за другой,
# в массиве нет проблем с получением доступа любого элемента массива. Однако есть проблемы с
# добавлением и удалением элементов массива. Из-за того что движок языка программирования
# чаще всего резервирует после создания массива еще какое-то количество ячеек памяти сразу за
# массивом, добавление в конец массива не особо затратно.
# Однако при добавлении в начало или середину массива ровно как и удаление из начала массива является
# очень нагруженным процессом так как весь массив перезаписывается, что я и продемонстрирую


start = time.time()
arr = [i for i in  range(1, 1_000_000)]
end = time.time()
print("Создался список из 1_000_000 элементов за ", end - start)

start = time.time()
for i in range(1, 10_000):
    arr.append(i)
end = time.time()
print("Добавились 10_000 элементов в конец списка за ", end - start)

start = time.time()
for i in range(1, 10_000):
    arr.pop()
end = time.time()
print("Удалились 10_000 элементов с конца списка за ", end - start)

start = time.time()
for i in range(1, 10_000):
    arr.insert(0, i)
end = time.time()
print("Добавились 10_000 элементов в начала списка за ", end - start)

start = time.time()
for i in range(1, 10_000):
    arr.pop(0)
end = time.time()
print("Удалились 10_000 элементов с начала списка за ", end - start)


# Быстрее создать новый список из 10_000 элементов и в конец его добавить
# 1_000_000 элементов чем в изначальный список из 1_000_000 значений в начало добавить 10_000 элементов
# так как из-за специфики работы массива, ему нужно перезаписывать все значения, что может быть затратно.
start = time.time()
newArr = [range(1, 10_000)]
for i in arr:
    newArr.append(i)
end = time.time()
print("Создалися список из 10_000 элементов  в который добавился список из 1_000_000", end - start)
